ZIP(1L)                                                                ZIP(1L)

NNAAMMEE
       zip - package and compress (archive) files

SSYYNNOOPPSSIISS
       zziipp [-aaAABBccddDDeeEEffFFgghhjjkkllLLmmooqqrrRRSSTTuuvvVVwwXXyyzz!!@@$$] [--longoption ...] [-bb path]
       [-nn suffixes] [-tt date] [-tttt date] [_z_i_p_f_i_l_e [_f_i_l_e ...]] [--xxii list]

       zziippccllooaakk (see separate man page)

       zziippnnoottee (see separate man page)

       zziippsspplliitt (see separate man page)

       Note:  Command line processing in _z_i_p has been changed to support long
       options and handle all options and arguments more consistently.  Some
       old command lines that depend on command line inconsistencies may no
       longer work.

DDEESSCCRRIIPPTTIIOONN
       _z_i_p is a compression and file packaging utility for Unix, VMS, MSDOS,
       OS/2, Windows 9x/NT/XP, Minix, Atari, Macintosh, Amiga, and Acorn RISC
       OS.  It is analogous to a combination of the Unix commands _t_a_r(1) and
       _c_o_m_p_r_e_s_s(1) and is compatible with PKZIP (Phil Katz's ZIP for MSDOS
       systems).

       A companion program (_u_n_z_i_p(1L)) unpacks _z_i_p archives.  The _z_i_p and
       _u_n_z_i_p(1L) programs can work with archives produced by PKZIP (supporting
       most PKZIP features up to PKZIP version 4.6), and PKZIP and PKUNZIP can
       work with archives produced by _z_i_p (with some exceptions, notably
       streamed archives, but recent changes in the zip file standard may
       facilitate better compatibility).  _z_i_p version 3.0 is compatible with
       PKZIP 2.04 and also supports the Zip64 extensions of PKZIP 4.5 which
       allow archives as well as files to exceed the previous 2 GB limit (4 GB
       in some cases).  _z_i_p also now supports bbzziipp22 compression if the bbzziipp22
       library is included when _z_i_p is compiled.  Note that PKUNZIP 1.10
       cannot extract files produced by PKZIP 2.04 or _z_i_p_ _3_._0. You must use
       PKUNZIP 2.04g or _u_n_z_i_p_ _5_._0_p_1 (or later versions) to extract them.

       See the EEXXAAMMPPLLEESS section at the bottom of this page for examples of
       some typical uses of _z_i_p.

       LLaarrggee  AArrcchhiivveess  aanndd  ZZiipp6644.. _z_i_p automatically uses the Zip64 extensions
       when files larger than 4 GB are added to an archive, an archive
       containing Zip64 entries is updated (if the resulting archive still
       needs Zip64), the size of the archive will exceed 4 GB, or when the
       number of entries in the archive will exceed about 64K.  Zip64 is also
       used for archives streamed from standard input as the size of such
       archives are not known in advance, but the option --ffzz-- can be used to
       force _z_i_p to create PKZIP 2 compatible archives (as long as Zip64
       extensions are not needed).  You must use a PKZIP 4.5 compatible unzip,
       such as _u_n_z_i_p_ _6_._0 or later, to extract files using the Zip64
       extensions.

       In addition, streamed archives, entries encrypted with standard
       encryption, or split archives created with the pause option may not be
       compatible with PKZIP as data descriptors are used and PKZIP at the
       time of this writing does not support data descriptors (but recent
       changes in the PKWare published zip standard now include some support
       for the data descriptor format _z_i_p uses).


       MMaacc OOSS XX..  Though previous Mac versions had their own _z_i_p port, _z_i_p
       supports Mac OS X as part of the Unix port and most Unix features
       apply.  References to "MacOS" below generally refer to MacOS versions
       older than OS X.  Support for some Mac OS features in the Unix Mac OS X
       port, such as resource forks, is expected in the next _z_i_p release.


       For a brief help on _z_i_p and _u_n_z_i_p, run each without specifying any
       parameters on the command line.


UUSSEE
       The program is useful for packaging a set of files for distribution;
       for archiving files; and for saving disk space by temporarily
       compressing unused files or directories.

       The _z_i_p program puts one or more compressed files into a single _z_i_p
       archive, along with information about the files (name, path, date, time
       of last modification, protection, and check information to verify file
       integrity).  An entire directory structure can be packed into a _z_i_p
       archive with a single command.  Compression ratios of 2:1 to 3:1 are
       common for text files.  _z_i_p has one compression method (deflation) and
       can also store files without compression.  (If bbzziipp22 support is added,
       _z_i_p can also compress using bbzziipp22 compression, but such entries require
       a reasonably modern unzip to decompress.  When bbzziipp22 compression is
       selected, it replaces deflation as the default method.)  _z_i_p
       automatically chooses the better of the two (deflation or store or, if
       bbzziipp22 is selected, bbzziipp22 or store) for each file to be compressed.

       CCoommmmaanndd  ffoorrmmaatt..  The basic command format is

              zziipp options archive inpath inpath ...

       where aarrcchhiivvee is a new or existing _z_i_p archive and iinnppaatthh is a
       directory or file path optionally including wildcards.  When given the
       name of an existing _z_i_p archive, _z_i_p will replace identically named
       entries in the _z_i_p archive (matching the relative names as stored in
       the archive) or add entries for new names.  For example, if _f_o_o_._z_i_p
       exists and contains _f_o_o_/_f_i_l_e_1 and _f_o_o_/_f_i_l_e_2, and the directory _f_o_o
       contains the files _f_o_o_/_f_i_l_e_1 and _f_o_o_/_f_i_l_e_3, then:

              zip -r foo.zip foo

       or more concisely

              zip -r foo foo

       will replace _f_o_o_/_f_i_l_e_1 in _f_o_o_._z_i_p and add _f_o_o_/_f_i_l_e_3 to _f_o_o_._z_i_p.  After
       this, _f_o_o_._z_i_p contains _f_o_o_/_f_i_l_e_1, _f_o_o_/_f_i_l_e_2, and _f_o_o_/_f_i_l_e_3, with
       _f_o_o_/_f_i_l_e_2 unchanged from before.

       So if before the zip command is executed _f_o_o_._z_i_p has:

               foo/file1 foo/file2

       and directory foo has:

               file1 file3

       then _f_o_o_._z_i_p will have:

               foo/file1 foo/file2 foo/file3

       where _f_o_o_/_f_i_l_e_1 is replaced and _f_o_o_/_f_i_l_e_3 is new.

       --@@  ffiillee  lliissttss..  If a file list is specified as --@@ [Not on MacOS], _z_i_p
       takes the list of input files from standard input instead of from the
       command line.  For example,

              zip -@ foo

       will store the files listed one per line on stdin in _f_o_o_._z_i_p.

       Under Unix, this option can be used to powerful effect in conjunction
       with the _f_i_n_d (1) command.  For example, to archive all the C source
       files in the current directory and its subdirectories:

              find . -name "*.[ch]" -print | zip source -@

       (note that the pattern must be quoted to keep the shell from expanding
       it).

       SSttrreeaammiinngg  iinnppuutt  aanndd  oouuttppuutt.. _z_i_p will also accept a single dash ("-") as
       the zip file name, in which case it will write the zip file to standard
       output, allowing the output to be piped to another program. For
       example:

              zip -r - . | dd of=/dev/nrst0 obs=16k

       would write the zip output directly to a tape with the specified block
       size for the purpose of backing up the current directory.

       _z_i_p also accepts a single dash ("-") as the name of a file to be
       compressed, in which case it will read the file from standard input,
       allowing zip to take input from another program. For example:

              tar cf - . | zip backup -

       would compress the output of the tar command for the purpose of backing
       up the current directory. This generally produces better compression
       than the previous example using the -r option because _z_i_p can take
       advantage of redundancy between files. The backup can be restored using
       the command

              unzip -p backup | tar xf -

       When no zip file name is given and stdout is not a terminal, _z_i_p acts
       as a filter, compressing standard input to standard output.  For
       example,

              tar cf - . | zip | dd of=/dev/nrst0 obs=16k

       is equivalent to

              tar cf - . | zip - - | dd of=/dev/nrst0 obs=16k

       _z_i_p archives created in this manner can be extracted with the program
       _f_u_n_z_i_p which is provided in the _u_n_z_i_p package, or by _g_u_n_z_i_p which is
       provided in the _g_z_i_p package (but some _g_u_n_z_i_p may not support this if
       _z_i_p used the Zip64 extensions). For example:

              dd if=/dev/nrst0  ibs=16k | funzip | tar xvf -

       The stream can also be saved to a file and _u_n_z_i_p used.

       If Zip64 support for large files and archives is enabled and _z_i_p is
       used as a filter, _z_i_p creates a Zip64 archive that requires a PKZIP 4.5
       or later compatible unzip to read it.  This is to avoid amgibuities in
       the zip file structure as defined in the current zip standard (PKWARE
       AppNote) where the decision to use Zip64 needs to be made before data
       is written for the entry, but for a stream the size of the data is not
       known at that point.  If the data is known to be smaller than 4 GB, the
       option --ffzz-- can be used to prevent use of Zip64, but _z_i_p will exit with
       an error if Zip64 was in fact needed.  _z_i_p_ _3 and _u_n_z_i_p_ _6 and later can
       read archives with Zip64 entries.  Also, _z_i_p removes the Zip64
       extensions if not needed when archive entries are copied (see the --UU
       (----ccooppyy) option).

       When directing the output to another file, note that all options should
       be before the redirection including --xx.  For example:

              zip archive "*.h" "*.c" -x donotinclude.h orthis.h > tofile

       ZZiipp  ffiilleess..  When changing an existing _z_i_p archive, _z_i_p will write a
       temporary file with the new contents, and only replace the old one when
       the process of creating the new version has been completed without
       error.

       If the name of the _z_i_p archive does not contain an extension, the
       extension ..zziipp is added. If the name already contains an extension
       other than ..zziipp, the existing extension is kept unchanged.  However,
       split archives (archives split over multiple files) require the ..zziipp
       extension on the last split.

       SSccaannnniinngg  aanndd  rreeaaddiinngg  ffiilleess.. When _z_i_p starts, it scans for files to
       process (if needed).  If this scan takes longer than about 5 seconds,
       _z_i_p will display a "Scanning files" message and start displaying
       progress dots every 2 seconds or every so many entries processed,
       whichever takes longer.  If there is more than 2 seconds between dots
       it could indicate that finding each file is taking time and could mean
       a slow network connection for example.  (Actually the initial file scan
       is a two-step process where the directory scan is followed by a sort
       and these two steps are separated with a space in the dots.  If
       updating an existing archive, a space also appears between the existing
       file scan and the new file scan.)  The scanning files dots are not
       controlled by the --ddss dot size option, but the dots are turned off by
       the --qq quiet option.  The --ssff show files option can be used to scan for
       files and get the list of files scanned without actually processing
       them.

       If _z_i_p is not able to read a file, it issues a warning but continues.
       See the --MMMM option below for more on how _z_i_p handles patterns that are
       not matched and files that are not readable.  If some files were
       skipped, a warning is issued at the end of the zip operation noting how
       many files were read and how many skipped.

       CCoommmmaanndd  mmooddeess..  _z_i_p now supports two distinct types of command modes,
       eexxtteerrnnaall and iinntteerrnnaall.  The eexxtteerrnnaall modes (add, update, and freshen)
       read files from the file system (as well as from an existing archive)
       while the iinntteerrnnaall modes (delete and copy) operate exclusively on
       entries in an existing archive.

       aadddd            
              Update existing entries and add new files.  If the archive does
              not exist create it.  This is the default mode.

       uuppddaattee  (--uu)
              Update existing entries if newer on the file system and add new
              files.  If the archive does not exist issue warning then create
              a new archive.

       ffrreesshheenn  (--ff)
              Update existing entries of an archive if newer on the file
              system.  Does not add new files to the archive.

       ddeelleettee  (--dd)
              Select entries in an existing archive and delete them.

       ccooppyy  (--UU)
              Select entries in an existing archive and copy them to a new
              archive.  This new mode is similar to uuppddaattee but command line
              patterns select entries in the existing archive rather than
              files from the file system and it uses the ----oouutt option to write
              the resulting archive to a new file rather than update the
              existing archive, leaving the original archive unchanged.

       The new File Sync option (--FFSS) is also considered a new mode, though it
       is similar to uuppddaattee.  This mode synchronizes the archive with the
       files on the OS, only replacing files in the archive if the file time
       or size of the OS file is different, adding new files, and deleting
       entries from the archive where there is no matching file.  As this mode
       can delete entries from the archive, consider making a backup copy of
       the archive.

       Also see --DDFF for creating difference archives.

       See each option description below for details and the EEXXAAMMPPLLEESS section
       below for examples.

       SSpplliitt  aarrcchhiivveess..  _z_i_p version 3.0 and later can create split archives.
       A sspplliitt aarrcchhiivvee is a standard zip archive split over multiple files.
       (Note that split archives are not just archives split in to pieces, as
       the offsets of entries are now based on the start of each split.
       Concatenating the pieces together will invalidate these offsets, but
       _u_n_z_i_p can usually deal with it.  _z_i_p will usually refuse to process
       such a spliced archive unless the --FFFF fix option is used to fix the
       offsets.)

       One use of split archives is storing a large archive on multiple
       removable media.  For a split archive with 20 split files the files are
       typically named (replace ARCHIVE with the name of your archive)
       ARCHIVE.z01, ARCHIVE.z02, ..., ARCHIVE.z19, ARCHIVE.zip.  Note that the
       last file is the ..zziipp file.  In contrast, ssppaannnneedd aarrcchhiivveess are the
       original multi-disk archive generally requiring floppy disks and using
       volume labels to store disk numbers.  _z_i_p supports split archives but
       not spanned archives, though a procedure exists for converting split
       archives of the right size to spanned archives.  The reverse is also
       true, where each file of a spanned archive can be copied in order to
       files with the above names to create a split archive.

       Use --ss to set the split size and create a split archive.  The size is
       given as a number followed optionally by one of k (kB), m (MB), g (GB),
       or t (TB) (the default is m).  The --sspp option can be used to pause _z_i_p
       between splits to allow changing removable media, for example, but read
       the descriptions and warnings for both --ss and --sspp below.

       Though _z_i_p does not update split archives, _z_i_p provides the new option
       --OO (----oouuttppuutt--ffiillee or ----oouutt) to allow split archives to be updated and
       saved in a new archive.  For example,

              zip inarchive.zip foo.c bar.c --out outarchive.zip

       reads archive iinnaarrcchhiivvee..zziipp, even if split, adds the files ffoooo..cc and
       bbaarr..cc, and writes the resulting archive to oouuttaarrcchhiivvee..zziipp.  If
       iinnaarrcchhiivvee..zziipp is split then oouuttaarrcchhiivvee..zziipp defaults to the same split
       size.  Be aware that if oouuttaarrcchhiivvee..zziipp and any split files that are
       created with it already exist, these are always overwritten as needed
       without warning.  This may be changed in the future.

       UUnniiccooddee..  Though the zip standard requires storing paths in an archive
       using a specific character set, in practice zips have stored paths in
       archives in whatever the local character set is.  This creates problems
       when an archive is created or updated on a system using one character
       set and then extracted on another system using a different character
       set.  When compiled with Unicode support enabled on platforms that
       support wide characters, _z_i_p now stores, in addition to the standard
       local path for backward compatibility, the UTF-8 translation of the
       path.  This provides a common universal character set for storing paths
       that allows these paths to be fully extracted on other systems that
       support Unicode and to match as close as possible on systems that
       don't.

       On Win32 systems where paths are internally stored as Unicode but
       represented in the local character set, it's possible that some paths
       will be skipped during a local character set directory scan.  _z_i_p with
       Unicode support now can read and store these paths.  Note that Win 9x
       systems and FAT file systems don't fully support Unicode.

       Be aware that console windows on Win32 and Unix, for example, sometimes
       don't accurately show all characters due to how each operating system
       switches in character sets for display.  However, directory navigation
       tools should show the correct paths if the needed fonts are loaded.

       CCoommmmaanndd lliinnee ffoorrmmaatt..  This version of _z_i_p has updated command line
       processing and support for long options.

       Short options take the form

              -s[-][s[-]...][value][=value][ value]

       where s is a one or two character short option.  A short option that
       takes a value is last in an argument and anything after it is taken as
       the value.  If the option can be negated and "-" immediately follows
       the option, the option is negated.  Short options can also be given as
       separate arguments

              -s[-][value][=value][ value] -s[-][value][=value][ value] ...

       Short options in general take values either as part of the same
       argument or as the following argument.  An optional = is also
       supported.  So

              -ttmmddyyyy

       and

              -tt=mmddyyyy

       and

              -tt mmddyyyy

       all work.  The --xx and --ii options accept lists of values and use a
       slightly different format described below.  See the --xx and --ii options.

       Long options take the form

              --longoption[-][=value][ value]

       where the option starts with --, has a multicharacter name, can include
       a trailing dash to negate the option (if the option supports it), and
       can have a value (option argument) specified by preceeding it with =
       (no spaces).  Values can also follow the argument.  So

              --before-date=mmddyyyy

       and

              --before-date mmddyyyy

       both work.

       Long option names can be shortened to the shortest unique abbreviation.
       See the option descriptions below for which support long options.  To
       avoid confusion, avoid abbreviating a negatable option with an embedded
       dash ("-") at the dash if you plan to negate it (the parser would
       consider a trailing dash, such as for the option ----ssoommee--ooppttiioonn using
       ----ssoommee-- as the option, as part of the name rather than a negating
       dash).  This may be changed to force the last dash in ----ssoommee-- to be
       negating in the future.

OOPPTTIIOONNSS
       --aa
       ----aasscciiii
              [Systems using EBCDIC] Translate file to ASCII format.


       --AA
       ----aaddjjuusstt--ssffxx
              Adjust self-extracting executable archive.  A self-extracting
              executable archive is created by prepending the SFX stub to an
              existing archive. The --AA option tells _z_i_p to adjust the entry
              offsets stored in the archive to take into account this
              "preamble" data.

       Note: self-extracting archives for the Amiga are a special case.  At
       present, only the Amiga port of _z_i_p is capable of adjusting or updating
       these without corrupting them. -J can be used to remove the SFX stub if
       other updates need to be made.


       --AACC
       ----aarrcchhiivvee--cclleeaarr
              [WIN32]  Once archive is created (and tested if --TT is used,
              which is recommended), clear the archive bits of files
              processed.  WARNING: Once the bits are cleared they are cleared.
              You may want to use the --ssff show files option to store the list
              of files processed in case the archive operation must be
              repeated.  Also consider using the --MMMM must match option.  Be
              sure to check out --DDFF as a possibly better way to do incremental
              backups.


       --AASS
       ----aarrcchhiivvee--sseett
              [WIN32]  Only include files that have the archive bit set.
              Directories are not stored when --AASS is used, though by default
              the paths of entries, including directories, are stored as usual
              and can be used by most unzips to recreate directories.

              The archive bit is set by the operating system when a file is
              modified and, if used with --AACC, --AASS can provide an incremental
              backup capability.  However, other applications can modify the
              archive bit and it may not be a reliable indicator of which
              files have changed since the last archive operation.
              Alternative ways to create incremental backups are using --tt to
              use file dates, though this won't catch old files copied to
              directories being archived, and --DDFF to create a differential
              archive.


       --BB
       ----bbiinnaarryy
              [VM/CMS and MVS] force file to be read binary (default is text).


       --BBn    [TANDEM] set Edit/Enscribe formatting options with n defined as
              bit  0: Don't add delimiter (Edit/Enscribe)
              bit  1: Use LF rather than CR/LF as delimiter (Edit/Enscribe)
              bit  2: Space fill record to maximum record length (Enscribe)
              bit  3: Trim trailing space (Enscribe)
              bit  8: Force 30K (Expand) large read for unstructured files


       --bb  path
       ----tteemmpp--ppaatthh  path
              Use the specified _p_a_t_h for the temporary _z_i_p archive. For
              example:

                     zip -b /tmp stuff *

              will put the temporary _z_i_p archive in the directory _/_t_m_p,
              copying over _s_t_u_f_f_._z_i_p to the current directory when done. This
              option is useful when updating an existing archive and the file
              system containing this old archive does not have enough space to
              hold both old and new archives at the same time.  It may also be
              useful when streaming in some cases to avoid the need for data
              descriptors.  Note that using this option may require _z_i_p take
              additional time to copy the archive file when done to the
              destination file system.


       --cc
       ----eennttrryy--ccoommmmeennttss
              Add one-line comments for each file.  File operations (adding,
              updating) are done first, and the user is then prompted for a
              one-line comment for each file.  Enter the comment followed by
              return, or just return for no comment.


       --CC
       ----pprreesseerrvvee--ccaassee
              [VMS]  Preserve case all on VMS.  Negating this option (--CC--)
              downcases.


       --CC22
       ----pprreesseerrvvee--ccaassee--22
              [VMS]  Preserve case ODS2 on VMS.  Negating this option (--CC22--)
              downcases.


       --CC55
       ----pprreesseerrvvee--ccaassee--55
              [VMS]  Preserve case ODS5 on VMS.  Negating this option (--CC55--)
              downcases.


       --dd
       ----ddeelleettee
              Remove (delete) entries from a _z_i_p archive.  For example:

                     zip -d foo foo/tom/junk foo/harry/\* \*.o

              will remove the entry _f_o_o_/_t_o_m_/_j_u_n_k, all of the files that start
              with _f_o_o_/_h_a_r_r_y_/, and all of the files that end with ..oo (in any
              path).  Note that shell pathname expansion has been inhibited
              with backslashes, so that _z_i_p can see the asterisks, enabling
              _z_i_p to match on the contents of the _z_i_p archive instead of the
              contents of the current directory.  (The backslashes are not
              used on MSDOS-based platforms.)  Can also use quotes to escape
              the asterisks as in

                     zip -d foo foo/tom/junk "foo/harry/*" "*.o"

              Not escaping the asterisks on a system where the shell expands
              wildcards could result in the asterisks being converted to a
              list of files in the current directory and that list used to
              delete entries from the archive.

              Under MSDOS, --dd is case sensitive when it matches names in the
              _z_i_p archive.  This requires that file names be entered in upper
              case if they were zipped by PKZIP on an MSDOS system.  (We
              considered making this case insensitive on systems where paths
              were case insensitive, but it is possible the archive came from
              a system where case does matter and the archive could include
              both BBaarr and bbaarr as separate files in the archive.)  But see the
              new option --iicc to ignore case in the archive.


       --ddbb
       ----ddiissppllaayy--bbyytteess
              Display running byte counts showing the bytes zipped and the
              bytes to go.


       --ddcc
       ----ddiissppllaayy--ccoouunnttss
              Display running count of entries zipped and entries to go.


       --dddd
       ----ddiissppllaayy--ddoottss
              Display dots while each entry is zipped (except on ports that
              have their own progress indicator).  See --ddss below for setting
              dot size.  The default is a dot every 10 MB of input file
              processed.  The --vv option also displays dots (previously at a
              much higher rate than this but now --vv also defaults to 10 MB)
              and this rate is also controlled by --ddss.


       --ddff
       ----ddaattaaffoorrkk
              [MacOS] Include only data-fork of files zipped into the archive.
              Good for exporting files to foreign operating-systems.
              Resource-forks will be ignored at all.


       --ddgg
       ----ddiissppllaayy--gglloobbaallddoottss
              Display progress dots for the archive instead of for each file.
              The command

                         zip -qdgds 10m

              will turn off most output except dots every 10 MB.


       --ddss  size
       ----ddoott--ssiizzee  size
              Set amount of input file processed for each dot displayed.  See
              --dddd to enable displaying dots.  Setting this option implies --dddd.
              Size is in the format nm where n is a number and m is a
              multiplier.  Currently m can be k (KB), m (MB), g (GB), or t
              (TB), so if n is 100 and m is k, size would be 100k which is 100
              KB.  The default is 10 MB.

              The --vv option also displays dots and now defaults to 10 MB also.
              This rate is also controlled by this option.  A size of 0 turns
              dots off.

              This option does not control the dots from the "Scanning files"
              message as _z_i_p scans for input files.  The dot size for that is
              fixed at 2 seconds or a fixed number of entries, whichever is
              longer.


       --dduu
       ----ddiissppllaayy--uussiizzee
              Display the uncompressed size of each entry.


       --ddvv
       ----ddiissppllaayy--vvoolluummee
              Display the volume (disk) number each entry is being read from,
              if reading an existing archive, and being written to.


       --DD
       ----nnoo--ddiirr--eennttrriieess
              Do not create entries in the _z_i_p archive for directories.
              Directory entries are created by default so that their
              attributes can be saved in the zip archive.  The environment
              variable ZIPOPT can be used to change the default options. For
              example under Unix with sh:

                     ZIPOPT="-D"; export ZIPOPT

              (The variable ZIPOPT can be used for any option, including --ii
              and --xx using a new option format detailed below, and can include
              several options.) The option --DD is a shorthand for --xx "*/" but
              the latter previously could not be set as default in the ZIPOPT
              environment variable as the contents of ZIPOPT gets inserted
              near the beginning of the command line and the file list had to
              end at the end of the line.

              This version of _z_i_p does allow --xx and --ii options in ZIPOPT if
              the form

               --xx file file ...  @@

              is used, where the @ (an argument that is just @) terminates the
              list.


       --DDFF
       ----ddiiffffeerreennccee--aarrcchhiivvee
              Create an archive that contains all new and changed files since
              the original archive was created.  For this to work, the input
              file list and current directory must be the same as during the
              original _z_i_p operation.

              For example, if the existing archive was created using

                     zip -r foofull .

              from the _b_a_r directory, then the command

                     zip -r foofull . -DF --out foonew

              also from the _b_a_r directory creates the archive _f_o_o_n_e_w with just
              the files not in _f_o_o_f_u_l_l and the files where the size or file
              time of the files do not match those in _f_o_o_f_u_l_l.

              Note that the timezone environment variable TZ should be set
              according to the local timezone in order for this option to work
              correctly.  A change in timezone since the original archive was
              created could result in no times matching and all files being
              included.

              A possible approach to backing up a directory might be to create
              a normal archive of the contents of the directory as a full
              backup, then use this option to create incremental backups.


       --ee
       ----eennccrryypptt
              Encrypt the contents of the _z_i_p archive using a password which
              is entered on the terminal in response to a prompt (this will
              not be echoed; if standard error is not a tty, _z_i_p will exit
              with an error).  The password prompt is repeated to save the
              user from typing errors.


       --EE
       ----lloonnggnnaammeess
              [OS/2] Use the .LONGNAME Extended Attribute (if found) as
              filename.


       --ff
       ----ffrreesshheenn
              Replace (freshen) an existing entry in the _z_i_p archive only if
              it has been modified more recently than the version already in
              the _z_i_p archive; unlike the update option (--uu) this will not add
              files that are not already in the _z_i_p archive.  For example:

                     zip -f foo

              This command should be run from the same directory from which
              the original _z_i_p command was run, since paths stored in _z_i_p
              archives are always relative.

              Note that the timezone environment variable TZ should be set
              according to the local timezone in order for the --ff, --uu and --oo
              options to work correctly.

              The reasons behind this are somewhat subtle but have to do with
              the differences between the Unix-format file times (always in
              GMT) and most of the other operating systems (always local time)
              and the necessity to compare the two.  A typical TZ value is
              ``MET-1MEST'' (Middle European time with automatic adjustment
              for ``summertime'' or Daylight Savings Time).

              The format is TTThhDDD, where TTT is the time zone such as MET,
              hh is the difference between GMT and local time such as -1
              above, and DDD is the time zone when daylight savings time is in
              effect.  Leave off the DDD if there is no daylight savings time.
              For the US Eastern time zone EST5EDT.


       --FF
       ----ffiixx            
       --FFFF
       ----ffiixxffiixx    
              Fix the _z_i_p archive. The --FF option can be used if some portions
              of the archive are missing, but requires a reasonably intact
              central directory.  The input archive is scanned as usual, but
              _z_i_p will ignore some problems.  The resulting archive should be
              valid, but any inconsistent entries will be left out.

              When doubled as in --FFFF, the archive is scanned from the
              beginning and _z_i_p scans for special signatures to identify the
              limits between the archive members. The single --FF is more
              reliable if the archive is not too much damaged, so try this
              option first.

              If the archive is too damaged or the end has been truncated, you
              must use --FFFF.  This is a change from _z_i_p_ _2_._3_2, where the --FF
              option is able to read a truncated archive.  The --FF option now
              more reliably fixes archives with minor damage and the --FFFF
              option is needed to fix archives where --FF might have been
              sufficient before.

              Neither option will recover archives that have been incorrectly
              transferred in ascii mode instead of binary. After the repair,
              the --tt option of _u_n_z_i_p may show that some files have a bad CRC.
              Such files cannot be recovered; you can remove them from the
              archive using the --dd option of _z_i_p.

              Note that --FFFF may have trouble fixing archives that include an
              embedded zip archive that was stored (without compression) in
              the archive and, depending on the damage, it may find the
              entries in the embedded archive rather than the archive itself.
              Try --FF first as it does not have this problem.

              The format of the fix commands have changed.  For example, to
              fix the damaged archive _f_o_o_._z_i_p,

                     zip -F foo --out foofix

              tries to read the entries normally, copying good entries to the
              new archive _f_o_o_f_i_x_._z_i_p.  If this doesn't work, as when the
              archive is truncated, or if some entries you know are in the
              archive are missed, then try

                     zip -FF foo --out foofixfix

              and compare the resulting archive to the archive created by --FF.
              The --FFFF option may create an inconsistent archive.  Depending on
              what is damaged, you can then use the --FF option to fix that
              archive.

              A split archive with missing split files can be fixed using --FF
              if you have the last split of the archive (the ..zziipp file).  If
              this file is missing, you must use --FFFF to fix the archive, which
              will prompt you for the splits you have.

              Currently the fix options can't recover entries that have a bad
              checksum or are otherwise damaged.


       --FFII
       ----ffiiffoo [Unix]  Normally _z_i_p skips reading any FIFOs (named pipes)
              encountered, as _z_i_p can hang if the FIFO is not being fed.  This
              option tells _z_i_p to read the contents of any FIFO it finds.


       --FFSS
       ----ffiilleessyynncc
              Synchronize the contents of an archive with the files on the OS.
              Normally when an archive is updated, new files are added and
              changed files are updated but files that no longer exist on the
              OS are not deleted from the archive.  This option enables a new
              mode that checks entries in the archive against the file system.
              If the file time and file size of the entry matches that of the
              OS file, the entry is copied from the old archive instead of
              being read from the file system and compressed.  If the OS file
              has changed, the entry is read and compressed as usual.  If the
              entry in the archive does not match a file on the OS, the entry
              is deleted.  Enabling this option should create archives that
              are the same as new archives, but since existing entries are
              copied instead of compressed, updating an existing archive with
              --FFSS can be much faster than creating a new archive.  Also
              consider using --uu for updating an archive.

              For this option to work, the archive should be updated from the
              same directory it was created in so the relative paths match.
              If few files are being copied from the old archive, it may be
              faster to create a new archive instead.

              Note that the timezone environment variable TZ should be set
              according to the local timezone in order for this option to work
              correctly.  A change in timezone since the original archive was
              created could result in no times matching and recompression of
              all files.

              This option deletes files from the archive.  If you need to
              preserve the original archive, make a copy of the archive first
              or use the ----oouutt option to output the updated archive to a new
              file.  Even though it may be slower, creating a new archive with
              a new archive name is safer, avoids mismatches between archive
              and OS paths, and is preferred.


       --gg
       ----ggrrooww             
              Grow (append to) the specified _z_i_p archive, instead of creating
              a new one. If this operation fails, _z_i_p attempts to restore the
              archive to its original state. If the restoration fails, the
              archive might become corrupted. This option is ignored when
              there's no existing archive or when at least one archive member
              must be updated or deleted.


       --hh
       --??
       ----hheellpp             
              Display the _z_i_p help information (this also appears if _z_i_p is
              run with no arguments).


       --hh22
       ----mmoorree--hheellpp
              Display extended help including more on command line format,
              pattern matching, and more obscure options.


       --ii  files
       ----iinncclluuddee  files
              Include only the specified files, as in:

                     zip -r foo . -i \*.c

              which will include only the files that end in .c in the current
              directory and its subdirectories. (Note for PKZIP users: the
              equivalent command is

                     pkzip -rP foo *.c

              PKZIP does not allow recursion in directories other than the
              current one.)  The backslash avoids the shell filename
              substitution, so that the name matching is performed by _z_i_p at
              all directory levels.  [This is for Unix and other systems where
              \  escapes the next character.  For other systems where the
              shell does not process * do not use \ and the above is

                     zip -r foo . -i *.c

              Examples are for Unix unless otherwise specified.]  So to
              include dir, a directory directly under the current directory,
              use

                     zip -r foo . -i dir/\*

              or

                     zip -r foo . -i "dir/*"

              to match paths such as dir/a and dir/b/file.c [on ports without
              wildcard expansion in the shell such as MSDOS and Windows

                     zip -r foo . -i dir/*

              is used.]  Note that currently the trailing / is needed for
              directories (as in

                     zip -r foo . -i dir/

              to include directory dir).

              The long option form of the first example is

                     zip -r foo . --include \*.c

              and does the same thing as the short option form.

              Though the command syntax used to require --ii at the end of the
              command line, this version actually allows --ii (or ----iinncclluuddee)
              anywhere.  The list of files terminates at the next argument
              starting with --, the end of the command line, or the list
              terminator @@ (an argument that is just @).  So the above can be
              given as

                     zip -i \*.c @ -r foo .

              for example.  There must be a space between the option and the
              first file of a list.  For just one file you can use the single
              value form

                     zip -i\*.c -r foo .

              (no space between option and value) or

                     zip --include=\*.c -r foo .

              as additional examples.  The single value forms are not
              recommended because they can be confusing and, in particular,
              the --iiffiillee format can cause problems if the first letter of ffiillee
              combines with ii to form a two-letter option starting with ii.
              Use --sscc to see how your command line will be parsed.

              Also possible:

                     zip -r foo  . -i@include.lst

              which will only include the files in the current directory and
              its subdirectories that match the patterns in the file
              include.lst.

              Files to --ii and --xx are patterns matching internal archive paths.
              See --RR for more on patterns.


       --II
       ----nnoo--iimmaaggee
              [Acorn RISC OS] Don't scan through Image files.  When used, _z_i_p
              will not consider Image files (eg. DOS partitions or Spark
              archives when SparkFS is loaded) as directories but will store
              them as single files.

              For example, if you have SparkFS loaded, zipping a Spark archive
              will result in a zipfile containing a directory (and its
              content) while using the 'I' option will result in a zipfile
              containing a Spark archive. Obviously this second case will also
              be obtained (without the 'I' option) if SparkFS isn't loaded.


       --iicc
       ----iiggnnoorree--ccaassee
              [VMS, WIN32] Ignore case when matching archive entries.  This
              option is only available on systems where the case of files is
              ignored.  On systems with case-insensitive file systems, case is
              normally ignored when matching files on the file system but is
              not ignored for -f (freshen), -d (delete), -U (copy), and
              similar modes when matching against archive entries (currently
              -f ignores case on VMS) because archive entries can be from
              systems where case does matter and names that are the same
              except for case can exist in an archive.  The --iicc option makes
              all matching case insensitive.  This can result in multiple
              archive entries matching a command line pattern.


       --jj
       ----jjuunnkk--ppaatthhss
              Store just the name of a saved file (junk the path), and do not
              store directory names. By default, _z_i_p will store the full path
              (relative to the current directory).


       --jjjj
       ----aabbssoolluuttee--ppaatthh
              [MacOS] record Fullpath (+ Volname). The complete path including
              volume will be stored. By default the relative path will be
              stored.


       --JJ
       ----jjuunnkk--ssffxx
              Strip any prepended data (e.g. a SFX stub) from the archive.

       --kk
       ----DDOOSS--nnaammeess
              Attempt to convert the names and paths to conform to MSDOS,
              store only the MSDOS attribute (just the user write attribute
              from Unix), and mark the entry as made under MSDOS (even though
              it was not); for compatibility with PKUNZIP under MSDOS which
              cannot handle certain names such as those with two dots.

       --ll
       ----ttoo--ccrrllff
              Translate the Unix end-of-line character LF into the MSDOS
              convention CR LF. This option should not be used on binary
              files.  This option can be used on Unix if the zip file is
              intended for PKUNZIP under MSDOS. If the input files already
              contain CR LF, this option adds an extra CR. This is to ensure
              that uunnzziipp --aa on Unix will get back an exact copy of the
              original file, to undo the effect of zziipp --ll.  See --llll for how
              binary files are handled.

       --llaa
       ----lloogg--aappppeenndd
              Append to existing logfile.  Default is to overwrite.

       --llff  logfilepath
       ----llooggffiillee--ppaatthh  logfilepath
              Open a logfile at the given path.  By default any existing file
              at that location is overwritten, but the --llaa option will result
              in an existing file being opened and the new log information
              appended to any existing information.  Only warnings and errors
              are written to the log unless the --llii option is also given, then
              all information messages are also written to the log.

       --llii
       ----lloogg--iinnffoo
              Include information messages, such as file names being zipped,
              in the log.  The default is to only include the command line,
              any warnings and errors, and the final status.

       --llll
       ----ffrroomm--ccrrllff
              Translate the MSDOS end-of-line CR LF into Unix LF.  This option
              should not be used on binary files.  This option can be used on
              MSDOS if the zip file is intended for unzip under Unix.  If the
              file is converted and the file is later determined to be binary
              a warning is issued and the file is probably corrupted.  In this
              release if --llll detects binary in the first buffer read from a
              file, _z_i_p now issues a warning and skips line end conversion on
              the file.  This check seems to catch all binary files tested,
              but the original check remains and if a converted file is later
              determined to be binary that warning is still issued.  A new
              algorithm is now being used for binary detection that should
              allow line end conversion of text files in UUTTFF--88 and similar
              encodings.

       --LL
       ----lliicceennssee
              Display the _z_i_p license.

       --mm
       ----mmoovvee       
              Move the specified files into the _z_i_p archive; actually, this
              deletes the target directories/files after making the specified
              _z_i_p archive. If a directory becomes empty after removal of the
              files, the directory is also removed. No deletions are done
              until _z_i_p has created the archive without error.  This is useful
              for conserving disk space, but is potentially dangerous so it is
              recommended to use it in combination with --TT to test the archive
              before removing all input files.

       --MMMM
       ----mmuusstt--mmaattcchh
              All input patterns must match at least one file and all input
              files found must be readable.  Normally when an input pattern
              does not match a file the "name not matched" warning is issued
              and when an input file has been found but later is missing or
              not readable a missing or not readable warning is issued.  In
              either case _z_i_p continues creating the archive, with missing or
              unreadable new files being skipped and files already in the
              archive remaining unchanged.  After the archive is created, if
              any files were not readable _z_i_p returns the OPEN error code (18
              on most systems) instead of the normal success return (0 on most
              systems).  With --MMMM set, _z_i_p exits as soon as an input pattern
              is not matched (whenever the "name not matched" warning would be
              issued) or when an input file is not readable.  In either case
              _z_i_p exits with an OPEN error and no archive is created.

              This option is useful when a known list of files is to be zipped
              so any missing or unreadable files will result in an error.  It
              is less useful when used with wildcards, but _z_i_p will still exit
              with an error if any input pattern doesn't match at least one
              file and if any matched files are unreadable.  If you want to
              create the archive anyway and only need to know if files were
              skipped, don't use --MMMM and just check the return code.  Also --llff
              could be useful.

       --nn  suffixes
       ----ssuuffffiixxeess  suffixes
              Do not attempt to compress files named with the given ssuuffffiixxeess.
              Such files are simply stored (0% compression) in the output zip
              file, so that _z_i_p doesn't waste its time trying to compress
              them.  The suffixes are separated by either colons or
              semicolons.  For example:

                     zip -rn .Z:.zip:.tiff:.gif:.snd  foo foo

              will copy everything from _f_o_o into _f_o_o_._z_i_p, but will store any
              files that end in _._Z, _._z_i_p, _._t_i_f_f, _._g_i_f, or _._s_n_d without trying
              to compress them (image and sound files often have their own
              specialized compression methods).  By default, _z_i_p does not
              compress files with extensions in the list
              _._Z_:_._z_i_p_:_._z_o_o_:_._a_r_c_:_._l_z_h_:_._a_r_j_.  Such files are stored directly in
              the output archive.  The environment variable ZIPOPT can be used
              to change the default options. For example under Unix with csh:

                     setenv ZIPOPT "-n .gif:.zip"

              To attempt compression on all files, use:

                     zip -n : foo

              The maximum compression option --99 also attempts compression on
              all files regardless of extension.

              On Acorn RISC OS systems the suffixes are actually filetypes (3
              hex digit format). By default, _z_i_p does not compress files with
              filetypes in the list DDC:D96:68E (i.e. Archives, CFS files and
              PackDir files).

       --nnww
       ----nnoo--wwiilldd
              Do not perform internal wildcard processing (shell processing of
              wildcards is still done by the shell unless the arguments are
              escaped).  Useful if a list of paths is being read and no
              wildcard substitution is desired.

       --NN
       ----nnootteess
              [Amiga, MacOS] Save Amiga or MacOS filenotes as zipfile
              comments. They can be restored by using the -N option of _u_n_z_i_p.
              If -c is used also, you are prompted for comments only for those
              files that do not have filenotes.

       --oo
       ----llaatteesstt--ttiimmee
              Set the "last modified" time of the _z_i_p archive to the latest
              (oldest) "last modified" time found among the entries in the _z_i_p
              archive.  This can be used without any other operations, if
              desired.  For example:

              zip -o foo

              will change the last modified time of ffoooo..zziipp to the latest time
              of the entries in ffoooo..zziipp.

       --OO output-file
       ----oouuttppuutt--ffiillee output-file
              Process the archive changes as usual, but instead of updating
              the existing archive, output the new archive to output-file.
              Useful for updating an archive without changing the existing
              archive and the input archive must be a different file than the
              output archive.

              This option can be used to create updated split archives.  It
              can also be used with --UU to copy entries from an existing
              archive to a new archive.  See the EEXXAAMMPPLLEESS section below.

              Another use is converting _z_i_p files from one split size to
              another.  For instance, to convert an archive with 700 MB CD
              splits to one with 2 GB DVD splits, can use:

                     zip -s 2g cd-split.zip --out dvd-split.zip

              which uses copy mode.  See --UU below.  Also:

                     zip -s 0 split.zip --out unsplit.zip

              will convert a split archive to a single-file archive.

              Copy mode will convert stream entries (using data descriptors
              and which should be compatible with most unzips) to normal
              entries (which should be compatible with all unzips), except if
              standard encryption was used.  For archives with encrypted
              entries, _z_i_p_c_l_o_a_k will decrypt the entries and convert them to
              normal entries.

       --pp
       ----ppaatthhss
              Include relative file paths as part of the names of files stored
              in the archive.  This is the default.  The --jj option junks the
              paths and just stores the names of the files.

       --PP  password
       ----ppaasssswwoorrdd  password
              Use _p_a_s_s_w_o_r_d to encrypt zipfile entries (if any).  TTHHIISS IISS
              IINNSSEECCUURREE!!  Many multi-user operating systems provide ways for
              any user to see the current command line of any other user; even
              on stand-alone systems there is always the threat of over-the-
              shoulder peeking.  Storing the plaintext password as part of a
              command line in an automated script is even worse.  Whenever
              possible, use the non-echoing, interactive prompt to enter
              passwords.  (And where security is truly important, use strong
              encryption such as Pretty Good Privacy instead of the relatively
              weak standard encryption provided by zipfile utilities.)

       --qq
       ----qquuiieett
              Quiet mode; eliminate informational messages and comment
              prompts.  (Useful, for example, in shell scripts and background
              tasks).

       --QQn
       ----QQ--ffllaagg  n
              [QDOS] store information about the file in the file header with
              n defined as
              bit  0: Don't add headers for any file
              bit  1: Add headers for all files
              bit  2: Don't wait for interactive key press on exit

       --rr
       ----rreeccuurrssee--ppaatthhss
              Travel the directory structure recursively; for example:

                     zip -r foo.zip foo

              or more concisely

                     zip -r foo foo

              In this case, all the files and directories in ffoooo are saved in
              a _z_i_p archive named ffoooo..zziipp, including files with names starting
              with "".."", since the recursion does not use the shell's file-name
              substitution mechanism.  If you wish to include only a specific
              subset of the files in directory ffoooo and its subdirectories, use
              the --ii option to specify the pattern of files to be included.
              You should not use --rr with the name ""..**"", since that matches
              ""...."" which will attempt to zip up the parent directory (probably
              not what was intended).

              Multiple source directories are allowed as in

                     zip -r foo foo1 foo2

              which first zips up ffoooo11 and then ffoooo22, going down each
              directory.

              Note that while wildcards to --rr are typically resolved while
              recursing down directories in the file system, any --RR,, --xx, and
              --ii wildcards are applied to internal archive pathnames once the
              directories are scanned.  To have wildcards apply to files in
              subdirectories when recursing on Unix and similar systems where
              the shell does wildcard substitution, either escape all
              wildcards or put all arguments with wildcards in quotes.  This
              lets _z_i_p see the wildcards and match files in subdirectories
              using them as it recurses.

       --RR
       ----rreeccuurrssee--ppaatttteerrnnss
              Travel the directory structure recursively starting at the
              current directory; for example:

                     zip -R foo "*.c"

              In this case, all the files matching **..cc in the tree starting at
              the current directory are stored into a _z_i_p archive named
              ffoooo..zziipp.  Note that **..cc will match ffiillee..cc, aa//ffiillee..cc and aa//bb//..cc.
              More than one pattern can be listed as separate arguments.  Note
              for PKZIP users: the equivalent command is

                     pkzip -rP foo *.c

              Patterns are relative file paths as they appear in the archive,
              or will after zipping, and can have optional wildcards in them.
              For example, given the current directory is ffoooo and under it are
              directories ffoooo11 and ffoooo22 and in ffoooo11 is the file bbaarr..cc,

                     zip -R foo/*

              will zip up ffoooo, ffoooo//ffoooo11, ffoooo//ffoooo11//bbaarr..cc, and ffoooo//ffoooo22.

                     zip -R */bar.c

              will zip up ffoooo//ffoooo11//bbaarr..cc.  See the note for --rr on escaping
              wildcards.


       --RREE
       ----rreeggeexx
              [WIN32]  Before _z_i_p _3_._0, regular expression list matching was
              enabled by default on Windows platforms.  Because of confusion
              resulting from the need to escape "[" and "]" in names, it is
              now off by default for Windows so "[" and "]" are just normal
              characters in names.  This option enables [] matching again.


       --ss  splitsize
       ----sspplliitt--ssiizzee  splitsize
              Enable creating a split archive and set the split size.  A split
              archive is an archive that could be split over many files.  As
              the archive is created, if the size of the archive reaches the
              specified split size, that split is closed and the next split
              opened.  In general all splits but the last will be the split
              size and the last will be whatever is left.  If the entire
              archive is smaller than the split size a single-file archive is
              created.

              Split archives are stored in numbered files.  For example, if
              the output archive is named aarrcchhiivvee and three splits are
              required, the resulting archive will be in the three files
              aarrcchhiivvee..zz0011, aarrcchhiivvee..zz0022, and aarrcchhiivvee..zziipp.  Do not change the
              numbering of these files or the archive will not be readable as
              these are used to determine the order the splits are read.

              Split size is a number optionally followed by a multiplier.
              Currently the number must be an integer.  The multiplier can
              currently be one of kk (kilobytes), mm (megabytes), gg (gigabytes),
              or tt (terabytes).  As 64k is the minimum split size, numbers
              without multipliers default to megabytes.  For example, to
              create a split archive called ffoooo with the contents of the bbaarr
              directory with splits of 670 MB that might be useful for burning
              on CDs, the command:

                     zip -s 670m -r foo bar

              could be used.

              Currently the old splits of a split archive are not excluded
              from a new archive, but they can be specifically excluded.  If
              possible, keep the input and output archives out of the path
              being zipped when creating split archives.

              Using --ss without --sspp as above creates all the splits where ffoooo
              is being written, in this case the current directory.  This
              split mode updates the splits as the archive is being created,
              requiring all splits to remain writable, but creates split
              archives that are readable by any unzip that supports split
              archives.  See --sspp below for enabling split pause mode which
              allows splits to be written directly to removable media.

              The option --ssvv can be used to enable verbose splitting and
              provide details of how the splitting is being done.  The --ssbb
              option can be used to ring the bell when _z_i_p pauses for the next
              split destination.

              Split archives cannot be updated, but see the --OO (----oouutt) option
              for how a split archive can be updated as it is copied to a new
              archive.  A split archive can also be converted into a single-
              file archive using a split size of 0 or negating the --ss option:

                     zip -s 0 split.zip --out single.zip

              Also see --UU (----ccooppyy) for more on using copy mode.

       --ssbb
       ----sspplliitt--bbeellll
              If splitting and using split pause mode, ring the bell when _z_i_p
              pauses for each split destination.

       --sscc
       ----sshhooww--ccoommmmaanndd
              Show the command line starting _z_i_p as processed and exit.  The
              new command parser permutes the arguments, putting all options
              and any values associated with them before any non-option
              arguments.  This allows an option to appear anywhere in the
              command line as long as any values that go with the option go
              with it.  This option displays the command line as _z_i_p sees it,
              including any arguments from the environment such as from the
              ZZIIPPOOPPTT variable.  Where allowed, options later in the command
              line can override options earlier in the command line.

       --ssff
       ----sshhooww--ffiilleess
              Show the files that would be operated on, then exit.  For
              instance, if creating a new archive, this will list the files
              that would be added.  If the option is negated, --ssff--, output
              only to an open log file.  Screen display is not recommended for
              large lists.

       --ssoo
       ----sshhooww--ooppttiioonnss
              Show all available options supported by _z_i_p as compiled on the
              current system.  As this command reads the option table, it
              should include all options.  Each line includes the short option
              (if defined), the long option (if defined), the format of any
              value that goes with the option, if the option can be negated,
              and a small description.  The value format can be no value,
              required value, optional value, single character value, number
              value, or a list of values.  The output of this option is not
              intended to show how to use any option but only show what
              options are available.

       --sspp
       ----sspplliitt--ppaauussee
              If splitting is enabled with --ss, enable split pause mode.  This
              creates split archives as --ss does, but stream writing is used so
              each split can be closed as soon as it is written and _z_i_p will
              pause between each split to allow changing split destination or
              media.

              Though this split mode allows writing splits directly to
              removable media, it uses stream archive format that may not be
              readable by some unzips.  Before relying on splits created with
              --sspp, test a split archive with the unzip you will be using.

              To convert a stream split archive (created with --sspp) to a
              standard archive see the ----oouutt option.

       --ssuu
       ----sshhooww--uunniiccooddee
              As --ssff, but also show Unicode version of the path if exists.

       --ssUU
       ----sshhooww--jjuusstt--uunniiccooddee
              As --ssff, but only show Unicode version of the path if exists,
              otherwise show the standard version of the path.

       --ssvv
       ----sspplliitt--vveerrbboossee
              Enable various verbose messages while splitting, showing how the
              splitting is being done.

       --SS
       ----ssyysstteemm--hhiiddddeenn
              [MSDOS, OS/2, WIN32 and ATARI] Include system and hidden files.
              [MacOS] Includes finder invisible files, which are ignored
              otherwise.

       --tt  mmddyyyy
       ----ffrroomm--ddaattee  mmddyyyy
              Do not operate on files modified prior to the specified date,
              where mmmm is the month (00-12), dddd is the day of the month
              (01-31), and yyyyyyyy is the year.  The _I_S_O_ _8_6_0_1 date format
              yyyyyyyy--mmmm--dddd is also accepted.  For example:

                     zip -rt 12071991 infamy foo

                     zip -rt 1991-12-07 infamy foo

              will add all the files in ffoooo and its subdirectories that were
              last modified on or after 7 December 1991, to the _z_i_p archive
              iinnffaammyy..zziipp.

       --tttt  mmddyyyy
       ----bbeeffoorree--ddaattee  mmddyyyy
              Do not operate on files modified after or at the specified date,
              where mmmm is the month (00-12), dddd is the day of the month
              (01-31), and yyyyyyyy is the year.  The _I_S_O_ _8_6_0_1 date format
              yyyyyyyy--mmmm--dddd is also accepted.  For example:

                     zip -rtt 11301995 infamy foo

                     zip -rtt 1995-11-30 infamy foo

              will add all the files in ffoooo and its subdirectories that were
              last modified before 30 November 1995, to the _z_i_p archive
              iinnffaammyy..zziipp.

       --TT
       ----tteesstt        
              Test the integrity of the new zip file. If the check fails, the
              old zip file is unchanged and (with the --mm option) no input
              files are removed.

       --TTTT  cmd
       ----uunnzziipp--ccoommmmaanndd  cmd
              Use command cmd instead of 'unzip -tqq' to test an archive when
              the --TT option is used.  On Unix, to use a copy of unzip in the
              current directory instead of the standard system unzip, could
              use:

               zip archive file1 file2 -T -TT "./unzip -tqq"

              In cmd, {} is replaced by the name of the temporary archive,
              otherwise the name of the archive is appended to the end of the
              command.  The return code is checked for success (0 on Unix).

       --uu
       ----uuppddaattee
              Replace (update) an existing entry in the _z_i_p archive only if it
              has been modified more recently than the version already in the
              _z_i_p archive.  For example:

                     zip -u stuff *

              will add any new files in the current directory, and update any
              files which have been modified since the _z_i_p archive _s_t_u_f_f_._z_i_p
              was last created/modified (note that _z_i_p will not try to pack
              _s_t_u_f_f_._z_i_p into itself when you do this).

              Note that the --uu option with no input file arguments acts like
              the --ff (freshen) option.

       --UU
       ----ccooppyy--eennttrriieess
              Copy entries from one archive to another.  Requires the ----oouutt
              option to specify a different output file than the input
              archive.  Copy mode is the reverse of --dd delete.  When delete is
              being used with ----oouutt, the selected entries are deleted from the
              archive and all other entries are copied to the new archive,
              while copy mode selects the files to include in the new archive.
              Unlike --uu update, input patterns on the command line are matched
              against archive entries only and not the file system files.  For
              instance,

                     zip inarchive "*.c" --copy --out outarchive

              copies entries with names ending in ..cc from iinnaarrcchhiivvee to
              oouuttaarrcchhiivvee.  The wildcard must be escaped on some systems to
              prevent the shell from substituting names of files from the file
              system which may have no relevance to the entries in the
              archive.

              If no input files appear on the command line and ----oouutt is used,
              copy mode is assumed:

                     zip inarchive --out outarchive

              This is useful for changing split size for instance.  Encrypting
              and decrypting entries is not yet supported using copy mode.
              Use _z_i_p_c_l_o_a_k for that.

       --UUNN  v
       ----uunniiccooddee  v
              Determine what _z_i_p should do with Unicode file names.  _z_i_p_ _3_._0,
              in addition to the standard file path, now includes the UTF-8
              translation of the path if the entry path is not entirely 7-bit
              ASCII.  When an entry is missing the Unicode path, _z_i_p reverts
              back to the standard file path.  The problem with using the
              standard path is this path is in the local character set of the
              zip that created the entry, which may contain characters that
              are not valid in the character set being used by the unzip.
              When _z_i_p is reading an archive, if an entry also has a Unicode
              path, _z_i_p now defaults to using the Unicode path to recreate the
              standard path using the current local character set.

              This option can be used to determine what _z_i_p should do with
              this path if there is a mismatch between the stored standard
              path and the stored UTF-8 path (which can happen if the standard
              path was updated).  In all cases, if there is a mismatch it is
              assumed that the standard path is more current and _z_i_p uses
              that.  Values for vv are

                     q - quit if paths do not match

                     w - warn, continue with standard path

                     i - ignore, continue with standard path

                     n - no Unicode, do not use Unicode paths

              The default is to warn and continue.

              Characters that are not valid in the current character set are
              escaped as ##UUxxxxxxxx and ##LLxxxxxxxxxxxx, where x is an ASCII character
              for a hex digit.  The first is used if a 16-bit character number
              is sufficient to represent the Unicode character and the second
              if the character needs more than 16 bits to represent it's
              Unicode character code.  Setting --UUNN to

                     e - escape

              as in

                     zip archive -sU -UN=e

              forces _z_i_p to escape all characters that are not printable 7-bit
              ASCII.

              Normally _z_i_p stores UTF-8 directly in the standard path field on
              systems where UTF-8 is the current character set and stores the
              UTF-8 in the new extra fields otherwise.  The option

                     u - UTF-8

              as in

                     zip archive dir -r -UN=UTF8

              forces _z_i_p to store UTF-8 as native in the archive.  Note that
              storing UTF-8 directly is the default on Unix systems that
              support it.  This option could be useful on Windows systems
              where the escaped path is too large to be a valid path and the
              UTF-8 version of the path is smaller, but native UTF-8 is not
              backward compatible on Windows systems.


       --vv
       ----vveerrbboossee
              Verbose mode or print diagnostic version info.

              Normally, when applied to real operations, this option enables
              the display of a progress indicator during compression (see --dddd
              for more on dots) and requests verbose diagnostic info about
              zipfile structure oddities.

              However, when --vv is the only command line argument a diagnostic
              screen is printed instead.  This should now work even if stdout
              is redirected to a file, allowing easy saving of the information
              for sending with bug reports to Info-ZIP.  The version screen
              provides the help screen header with program name, version, and
              release date, some pointers to the Info-ZIP home and
              distribution sites, and shows information about the target
              environment (compiler type and version, OS version, compilation
              date and the enabled optional features used to create the _z_i_p
              executable).

       --VV
       ----VVMMSS--ppoorrttaabbllee
              [VMS] Save VMS file attributes.  (Files are  truncated at EOF.)
              When a -V archive is unpacked on a non-VMS system,  some file
              types (notably Stream_LF text files  and  pure binary files
              like fixed-512) should be extracted intact.  Indexed files and
              file types with embedded record sizes (notably variable-length
              record types) will probably be seen as corrupt elsewhere.

       --VVVV
       ----VVMMSS--ssppeecciiffiicc
              [VMS] Save VMS file attributes, and  all allocated blocks in a
              file,  including  any  data beyond EOF.  Useful for moving ill-
              formed files  among  VMS systems.   When a -VV archive is
              unpacked on a non-VMS system, almost all files will appear
              corrupt.

       --ww
       ----VVMMSS--vveerrssiioonnss
              [VMS] Append the version number of the files to the name,
              including multiple versions of files.  Default is to use only
              the most recent version of a specified file.

       --wwww
       ----VVMMSS--ddoott--vveerrssiioonnss
              [VMS] Append the version number of the files to the name,
              including multiple versions of files, using the .nnn format.
              Default is to use only the most recent version of a specified
              file.

       --wwss
       ----wwiilldd--ssttoopp--ddiirrss
              Wildcards match only at a directory level.  Normally _z_i_p handles
              paths as strings and given the paths

                     /foo/bar/dir/file1.c

                     /foo/bar/file2.c

              an input pattern such as

                     /foo/bar/*

              normally would match both paths, the * matching ddiirr//ffiillee11..cc and
              ffiillee22..cc.  Note that in the first case a directory boundary (/)
              was crossed in the match.  With --wwss no directory bounds will be
              included in the match, making wildcards local to a specific
              directory level.  So, with --wwss enabled, only the second path
              would be matched.

              When using --wwss, use ** to match across directory boundaries as *
              does normally.

       --xx  files
       ----eexxcclluuddee  files
              Explicitly exclude the specified files, as in:

                     zip -r foo foo -x \*.o

              which will include the contents of ffoooo in ffoooo..zziipp while
              excluding all the files that end in ..oo.  The backslash avoids
              the shell filename substitution, so that the name matching is
              performed by _z_i_p at all directory levels.

              Also possible:

                     zip -r foo foo -x@exclude.lst

              which will include the contents of ffoooo in ffoooo..zziipp while
              excluding all the files that match the patterns in the file
              eexxcclluuddee..llsstt.

              The long option forms of the above are

                     zip -r foo foo --exclude \*.o

              and

                     zip -r foo foo --exclude @exclude.lst

              Multiple patterns can be specified, as in:

                     zip -r foo foo -x \*.o \*.c

              If there is no space between --xx and the pattern, just one value
              is assumed (no list):

                     zip -r foo foo -x\*.o

              See --ii for more on include and exclude.

       --XX
       ----nnoo--eexxttrraa
              Do not save extra file attributes (Extended Attributes on OS/2,
              uid/gid and file times on Unix).  The zip format uses extra
              fields to include additional information for each entry.  Some
              extra fields are specific to particular systems while others are
              applicable to all systems.  Normally when _z_i_p reads entries from
              an existing archive, it reads the extra fields it knows, strips
              the rest, and adds the extra fields applicable to that system.
              With --XX, _z_i_p strips all old fields and only includes the Unicode
              and Zip64 extra fields (currently these two extra fields cannot
              be disabled).

              Negating this option, --XX--, includes all the default extra
              fields, but also copies over any unrecognized extra fields.

       --yy
       ----ssyymmlliinnkkss
              For UNIX and VMS (V8.3 and later), store symbolic links as such
              in the _z_i_p archive, instead of compressing and storing the file
              referred to by the link.  This can avoid multiple copies of
              files being included in the archive as _z_i_p recurses the
              directory trees and accesses files directly and by links.

       --zz
       ----aarrcchhiivvee--ccoommmmeenntt
              Prompt for a multi-line comment for the entire _z_i_p archive.  The
              comment is ended by a line containing just a period, or an end
              of file condition (^D on Unix, ^Z on MSDOS, OS/2, and VMS).  The
              comment can be taken from a file:

                     zip -z foo < foowhat

       --ZZ  cm
       ----ccoommpprreessssiioonn--mmeetthhoodd  cm
              Set the default compression method.  Currently the main methods
              supported by _z_i_p are ssttoorree and ddeeffllaattee.  Compression method can
              be set to:

              ssttoorree - Setting the compression method to ssttoorree forces _z_i_p to
              store entries with no compression.  This is generally faster
              than compressing entries, but results in no space savings.  This
              is the same as using --00 (compression level zero).

              ddeeffllaattee - This is the default method for _z_i_p.  If _z_i_p determines
              that storing is better than deflation, the entry will be stored
              instead.

              bbzziipp22 - If bbzziipp22 support is compiled in, this compression method
              also becomes available.  Only some modern unzips currently
              support the bbzziipp22 compression method, so test the unzip you will
              be using before relying on archives using this method
              (compression method 12).

              For example, to add bbaarr..cc to archive ffoooo using bbzziipp22
              compression:

                     zip -Z bzip2 foo bar.c

              The compression method can be abbreviated:

                     zip -Zb foo bar.c

       --##
       ((--00,, --11,, --22,, --33,, --44,, --55,, --66,, --77,, --88,, --99))
              Regulate the speed of compression using the specified digit ##,
              where --00 indicates no compression (store all files), --11
              indicates the fastest compression speed (less compression) and
              --99 indicates the slowest compression speed (optimal compression,
              ignores the suffix list). The default compression level is --66..

              Though still being worked, the intention is this setting will
              control compression speed for all compression methods.
              Currently only deflation is controlled.

       --!!
       ----uussee--pprriivviilleeggeess
              [WIN32] Use priviliges (if granted) to obtain all aspects of
              WinNT security.

       --@@
       ----nnaammeess--ssttddiinn
              Take the list of input files from standard input. Only one
              filename per line.

       --$$
       ----vvoolluummee--llaabbeell
              [MSDOS, OS/2, WIN32] Include the volume label for the drive
              holding the first file to be compressed.  If you want to include
              only the volume label or to force a specific drive, use the
              drive name as first file name, as in:

                     zip -$ foo a: c:bar

EEXXAAMMPPLLEESS
       The simplest example:

              zip stuff *

       creates the archive _s_t_u_f_f_._z_i_p (assuming it does not exist) and puts all
       the files in the current directory in it, in compressed form (the ..zziipp
       suffix is added automatically, unless the archive name contains a dot
       already; this allows the explicit specification of other suffixes).

       Because of the way the shell on Unix does filename substitution, files
       starting with "." are not included; to include these as well:

              zip stuff .* *

       Even this will not include any subdirectories from the current
       directory.

       To zip up an entire directory, the command:

              zip -r foo foo

       creates the archive _f_o_o_._z_i_p, containing all the files and directories
       in the directory _f_o_o that is contained within the current directory.

       You may want to make a _z_i_p archive that contains the files in _f_o_o,
       without recording the directory name, _f_o_o.  You can use the --jj option
       to leave off the paths, as in:

              zip -j foo foo/*

       If you are short on disk space, you might not have enough room to hold
       both the original directory and the corresponding compressed _z_i_p
       archive.  In this case, you can create the archive in steps using the
       --mm option.  If _f_o_o contains the subdirectories _t_o_m, _d_i_c_k, and _h_a_r_r_y,
       you can:

              zip -rm foo foo/tom
              zip -rm foo foo/dick
              zip -rm foo foo/harry

       where the first command creates _f_o_o_._z_i_p, and the next two add to it.
       At the completion of each _z_i_p command, the last created archive is
       deleted, making room for the next _z_i_p command to function.




       Use --ss to set the split size and create a split archive.  The size is
       given as a number followed optionally by one of k (kB), m (MB), g (GB),
       or t (TB).  The command

              zip -s 2g -r split.zip foo

       creates a split archive of the directory foo with splits no bigger than
       2 GB each.  If foo contained 5 GB of contents and the contents were
       stored in the split archive without compression (to make this example
       simple), this would create three splits, split.z01 at 2 GB, split.z02
       at 2 GB, and split.zip at a little over 1 GB.

       The --sspp option can be used to pause _z_i_p between splits to allow
       changing removable media, for example, but read the descriptions and
       warnings for both --ss and --sspp below.

       Though _z_i_p does not update split archives, _z_i_p provides the new option
       --OO (----oouuttppuutt--ffiillee) to allow split archives to be updated and saved in a
       new archive.  For example,

              zip inarchive.zip foo.c bar.c --out outarchive.zip

       reads archive iinnaarrcchhiivvee..zziipp, even if split, adds the files ffoooo..cc and
       bbaarr..cc, and writes the resulting archive to oouuttaarrcchhiivvee..zziipp.  If
       iinnaarrcchhiivvee..zziipp is split then oouuttaarrcchhiivvee..zziipp defaults to the same split
       size.  Be aware that oouuttaarrcchhiivvee..zziipp and any split files that are
       created with it are always overwritten without warning.  This may be
       changed in the future.





PPAATTTTEERRNN MMAATTCCHHIINNGG
       This section applies only to Unix.  Watch this space for details on
       MSDOS and VMS operation.  However, the special wildcard characters **
       and [[]] below apply to at least MSDOS also.

       The Unix shells (_s_h, _c_s_h, _b_a_s_h, and others) normally do filename
       substitution (also called "globbing") on command arguments.  Generally
       the special characters are:

       ??      match any single character

       **      match any number of characters (including none)

       [[]]     match any character in the range indicated within the brackets
              (example: [a-f], [0-9]).  This form of wildcard matching allows
              a user to specify a list of characters between square brackets
              and if any of the characters match the expression matches.  For
              example:

                     zip archive "*.[hc]"

              would archive all files in the current directory that end in ..hh
              or ..cc.

              Ranges of characters are supported:

                     zip archive "[a-f]*"

              would add to the archive all files starting with "a" through
              "f".

              Negation is also supported, where any character in that position
              not in the list matches.  Negation is supported by adding !! or ^^
              to the beginning of the list:

                     zip archive "*.[!o]"

              matches files that don't end in ".o".

              On WIN32, [] matching needs to be turned on with the -RE option
              to avoid the confusion that names with [ or ] have caused.


       When these characters are encountered (without being escaped with a
       backslash or quotes), the shell will look for files relative to the
       current path that match the pattern, and replace the argument with a
       list of the names that matched.

       The _z_i_p program can do the same matching on names that are in the _z_i_p
       archive being modified or, in the case of the --xx (exclude) or --ii
       (include) options, on the list of files to be operated on, by using
       backslashes or quotes to tell the shell not to do the name expansion.
       In general, when _z_i_p encounters a name in the list of files to do, it
       first looks for the name in the file system.  If it finds it, it then
       adds it to the list of files to do.  If it does not find it, it looks
       for the name in the _z_i_p archive being modified (if it exists), using
       the pattern matching characters described above, if present.  For each
       match, it will add that name to the list of files to be processed,
       unless this name matches one given with the --xx option, or does not
       match any name given with the --ii option.

       The pattern matching includes the path, and so patterns like \*.o match
       names that end in ".o", no matter what the path prefix is.  Note that
       the backslash must precede every special character (i.e. ?*[]), or the
       entire argument must be enclosed in double quotes ("").

       In general, use backslashes or double quotes for paths that have
       wildcards to make _z_i_p do the pattern matching for file paths, and
       always for paths and strings that have spaces or wildcards for --ii, --xx,
       --RR, --dd, and --UU and anywhere _z_i_p needs to process the wildcards.

EENNVVIIRROONNMMEENNTT
       The following environment variables are read and used by _z_i_p as
       described.

       ZZIIPPOOPPTT    
              contains default options that will be used when running _z_i_p.
              The contents of this environment variable will get added to the
              command line just after the zziipp command.

       ZZIIPP          
              [Not on RISC OS and VMS] see ZIPOPT

       ZZiipp$$OOppttiioonnss
              [RISC OS] see ZIPOPT

       ZZiipp$$EExxttss
              [RISC OS] contains extensions separated by a : that will cause
              native filenames with one of the specified extensions to be
              added to the zip file with basename and extension swapped.

       ZZIIPP__OOPPTTSS
              [VMS] see ZIPOPT

SSEEEE AALLSSOO
       compress(1), shar(1L), tar(1), unzip(1L), gzip(1L)

DDIIAAGGNNOOSSTTIICCSS
       The exit status (or error level) approximates the exit codes defined by
       PKWARE and takes on the following values, except under VMS:

              0      normal; no errors or warnings detected.

              2      unexpected end of zip file.

              3      a generic error in the zipfile format was detected.
                     Processing may have completed successfully anyway; some
                     broken zipfiles created by other archivers have simple
                     work-arounds.

              4      _z_i_p was unable to allocate memory for one or more buffers
                     during program initialization.

              5      a severe error in the zipfile format was detected.
                     Processing probably failed immediately.

              6      entry too large to be processed (such as input files
                     larger than 2 GB when not using Zip64 or trying to read
                     an existing archive that is too large) or entry too large
                     to be split with _z_i_p_s_p_l_i_t

              7      invalid comment format

              8      _z_i_p -T failed or out of memory

              9      the user aborted _z_i_p prematurely with control-C (or
                     similar)

              10     _z_i_p encountered an error while using a temp file

              11     read or seek error

              12     _z_i_p has nothing to do

              13     missing or empty zip file

              14     error writing to a file

              15     _z_i_p was unable to create a file to write to

              16     bad command line parameters

              18     _z_i_p could not open a specified file to read

              19     _z_i_p was compiled with options not supported on this
                     system

       VMS interprets standard Unix (or PC) return values as other, scarier-
       looking things, so _z_i_p instead maps them into VMS-style status codes.
       In general, _z_i_p sets VMS Facility = 1955 (0x07A3), Code = 2*
       Unix_status, and an appropriate Severity (as specified in ziperr.h).
       More details are included in the VMS-specific documentation.  See
       [.vms]NOTES.TXT and [.vms]vms_msg_gen.c.

BBUUGGSS
       _z_i_p 3.0 is not compatible with PKUNZIP 1.10. Use _z_i_p 1.1 to produce _z_i_p
       files which can be extracted by PKUNZIP 1.10.

       _z_i_p files produced by _z_i_p 3.0 must not be _u_p_d_a_t_e_d by _z_i_p 1.1 or PKZIP
       1.10, if they contain encrypted members or if they have been produced
       in a pipe or on a non-seekable device. The old versions of _z_i_p or PKZIP
       would create an archive with an incorrect format.  The old versions can
       list the contents of the zip file but cannot extract it anyway (because
       of the new compression algorithm).  If you do not use encryption and
       use regular disk files, you do not have to care about this problem.

       Under VMS, not all of the odd file formats are treated properly.  Only
       stream-LF format _z_i_p files are expected to work with _z_i_p.  Others can
       be converted using Rahul Dhesi's BILF program.  This version of _z_i_p
       handles some of the conversion internally.  When using Kermit to
       transfer zip files from VMS to MSDOS, type "set file type block" on
       VMS.  When transfering from MSDOS to VMS, type "set file type fixed" on
       VMS.  In both cases, type "set file type binary" on MSDOS.

       Under some older VMS versions, _z_i_p may hang for file specifications
       that use DECnet syntax _f_o_o_:_:_*_._*_.

       On OS/2, zip cannot match some names, such as those including an
       exclamation mark or a hash sign.  This is a bug in OS/2 itself: the
       32-bit DosFindFirst/Next don't find such names.  Other programs such as
       GNU tar are also affected by this bug.

       Under OS/2, the amount of Extended Attributes displayed by DIR is (for
       compatibility) the amount returned by the 16-bit version of
       DosQueryPathInfo(). Otherwise OS/2 1.3 and 2.0 would report different
       EA sizes when DIRing a file.  However, the structure layout returned by
       the 32-bit DosQueryPathInfo() is a bit different, it uses extra padding
       bytes and link pointers (it's a linked list) to have all fields on
       4-byte boundaries for portability to future RISC OS/2 versions.
       Therefore the value reported by _z_i_p (which uses this 32-bit-mode size)
       differs from that reported by DIR.  _z_i_p stores the 32-bit format for
       portability, even the 16-bit MS-C-compiled version running on OS/2 1.3,
       so even this one shows the 32-bit-mode size.

AAUUTTHHOORRSS
       Copyright (C) 1997-2008 Info-ZIP.

       Currently distributed under the Info-ZIP license.

       Copyright (C) 1990-1997 Mark Adler, Richard B. Wales, Jean-loup Gailly,
       Onno van der Linden, Kai Uwe Rommel, Igor Mandrichenko, John Bush and
       Paul Kienitz.

       Original copyright:

       Permission is granted to any individual or institution to use, copy, or
       redistribute this software so long as all of the original files are
       included, that it is not sold for profit, and that this copyright
       notice is retained.

       LIKE ANYTHING ELSE THAT'S FREE, ZIP AND ITS ASSOCIATED UTILITIES ARE
       PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED
       OR IMPLIED. IN NO EVENT WILL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
       DAMAGES RESULTING FROM THE USE OF THIS SOFTWARE.

       Please send bug reports and comments using the web page at:
       _w_w_w_._i_n_f_o_-_z_i_p_._o_r_g.  For bug reports, please include the version of _z_i_p
       (see _z_i_p_ _-_h), the make options used to compile it (see _z_i_p_ _-_v), the
       machine and operating system in use, and as much additional information
       as possible.

AACCKKNNOOWWLLEEDDGGEEMMEENNTTSS
       Thanks to R. P. Byrne for his _S_h_r_i_n_k_._P_a_s program, which inspired this
       project, and from which the shrink algorithm was stolen; to Phil Katz
       for placing in the public domain the _z_i_p file format, compression
       format, and .ZIP filename extension, and for accepting minor changes to
       the file format; to Steve Burg for clarifications on the deflate
       format; to Haruhiko Okumura and Leonid Broukhis for providing some
       useful ideas for the compression algorithm; to Keith Petersen, Rich
       Wales, Hunter Goatley and Mark Adler for providing a mailing list and
       _f_t_p site for the Info-ZIP group to use; and most importantly, to the
       Info-ZIP group itself (listed in the file _i_n_f_o_z_i_p_._w_h_o) without whose
       tireless testing and bug-fixing efforts a portable _z_i_p would not have
       been possible.  Finally we should thank (blame) the first Info-ZIP
       moderator, David Kirschbaum, for getting us into this mess in the first
       place.  The manual page was rewritten for Unix by R. P. C. Rodgers and
       updated by E. Gordon for _z_i_p 3.0.

Info-ZIP                      16 June 2008 (v3.0)                      ZIP(1L)
